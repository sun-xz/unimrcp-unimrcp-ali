#ifdef _WIN32
/*
 * PLEASE NOTE: 
 * 
 * This file is automatically generated by tag_dll.awk.
 * It contains magic required by Win32 DLLs to initialize
 * tag_typedef_t variables.
 * 
 * Do not, repeat, do not edit this file. Edit 'auth_tag.c' instead.
 * 
 */

#define EXPORT __declspec(dllexport)

/*
 * This file is part of the Sofia-SIP package
 *
 * Copyright (C) 2005 Nokia Corporation.
 *
 * Contact: Pekka Pessi <pekka.pessi@nokia.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

/**@CFILE auth_tag.c
 * @brief Tags for authentication verification module for NTA servers.
 *
 * @author Pekka Pessi <Pekka.Pessi@nokia.com>.
 *
 * @date Created: Wed Apr 11 15:14:03 2001 ppessi
 */

#include "config.h"

#undef TAG_NAMESPACE
#define TAG_NAMESPACE "auth"

#define TAG_NAMESPACE "auth"

#include "sofia-sip/auth_module.h"

#include <sofia-sip/su_tag_class.h>
#include <sofia-sip/url_tag_class.h>

/**@def AUTHTAG_ANY()
 *
 * Filter tag matching any AUTHTAG_*().
 */
tag_typedef_t authtag_any;

/**@def AUTHTAG_MODULE()
 *
 * Pointer to an authentication server module (auth_mod_t).
 *
 * The tag item AUTHTAG_MODULE() contains pointer to an authentication server
 * module. It is used to pass an already initialized authentication module
 * to a server object (like web server or registrar object).
 */
EXPORT tag_typedef_t authtag_module_ref;
tag_typedef_t authtag_module;

/**@def AUTHTAG_METHOD()
 *
 * Name of the authentication scheme.
 *
 * The tag AUTHTAG_METHOD() specifies the authentication module and scheme
 * to be used by the auth_module. The name can specify a basic
 * authentication module, like "Digest" or "Basic", or an plugin module,
 * like "SGMF+Digest".
 *
 * @sa See <sofia-sip/auth_plugin.h> for plugin interface.
 */
EXPORT tag_typedef_t authtag_method_ref;
tag_typedef_t authtag_method;

/**@def AUTHTAG_REALM()
 *
 * Authentication realm used by authentication server.
 *
 * The tag authtag_method specifies the authentication realm used by the @b
 * auth_module.  For servers, the domain name in the request URI is inserted
 * in the realm returned to the client if the realm string contains an
 * asterisk @c "*".  Only the first asterisk is replaced by request domain
 * name.
 *
 * @p Default Value
 * "*".
 */
EXPORT tag_typedef_t authtag_realm_ref;
tag_typedef_t authtag_realm;

/**@def AUTHTAG_OPAQUE()
 *
 * Opaque data used by authentication server.
 *
 * The tag authtag_opaque is used to pass opaque data to the @b auth_module.
 * The opaque data will be included in all the challenges (however, the data
 * is prefixed with a "." and other opaque data used by the algorithms.
 *
 * @p Default Value
 * "".
 */
EXPORT tag_typedef_t authtag_opaque_ref;
tag_typedef_t authtag_opaque;

/**@def AUTHTAG_DB()
 *
 * Name of authentication database used by authentication server.
 *
 * The tag AUTHTAG_DB() specifies the file name used to store the
 * authentication data. The file contains triplets as follows:
 *
 * @code
 * user:password:realm
 * @endcode
 *
 * @note
 * Currently, the passwords are stored as plaintext.
 */
EXPORT tag_typedef_t authtag_db_ref;
tag_typedef_t authtag_db;

/**@def AUTHTAG_QOP()
 *
 * Quality-of-protection used by Digest authentication.
 *
 * The tag AUTHTAG_QOP() specifies the qop scheme to be used by the
 * digest authentication.
 */
EXPORT tag_typedef_t authtag_qop_ref;
tag_typedef_t authtag_qop;

/**@def AUTHTAG_ALGORITHM()
 *
 * Authentication algorithm used by Digest authentication.
 *
 * The tag AUTHTAG_ALGORITHM() specifies the qop scheme to be used by the
 * digest authentication.
 */
EXPORT tag_typedef_t authtag_algorithm_ref;
tag_typedef_t authtag_algorithm;

/**@def AUTHTAG_EXPIRES()
 *
 * Nonce expiration time for Digest authentication.
 *
 * The tag AUTHTAG_EXPIRES() specifies the time in seconds that a nonce is
 * considered valid. If 0, the nonce lifetime unbounded. The default time is
 * 3600 seconds.
 */
EXPORT tag_typedef_t authtag_expires_ref;
tag_typedef_t authtag_expires;

/**@def AUTHTAG_NEXT_EXPIRES()
 *
 * Next nonce expiration time for Digest authentication.
 *
 * The tag AUTHTAG_NEXT_EXPIRES() specifies the time in seconds that a
 * nextnonce sent in Authentication-Info header is considered valid. If 0,
 * the nonce lifetime is unbounded. The default time is 3600 seconds.
 */
EXPORT tag_typedef_t authtag_next_expires_ref;
tag_typedef_t authtag_next_expires;

/**@def AUTHTAG_MAX_NCOUNT()
 *
 * Max nonce count value.
 *
 * The tag AUTHTAG_MAX_NCOUNT() specifies the maximum number of times a
 * nonce should be used.
 *
 * @todo Count actual usages and don't trust "nc" parameter only.
 */
EXPORT tag_typedef_t authtag_max_ncount_ref;
tag_typedef_t authtag_max_ncount;

/**@def AUTHTAG_BLACKLIST()
 *
 * Blacklist time.
 *
 * The tag AUTHTAG_BLACKLIST() specifies the time the server delays its
 * response if it is given bad credentials or malformed nonce. The default
 * time is 5 seconds.
 *
 * @todo Implement delayed response.
 */
EXPORT tag_typedef_t authtag_blacklist_ref;
tag_typedef_t authtag_blacklist;

/**@def AUTHTAG_FORBIDDEN()
 *
 * Respond with 403 Forbidden.
 *
 * When given a true argument, the tag AUTHTAG_FORBIDDEN() specifies that the
 * server responds with 403 Forbidden (instead of 401/407) when it receives
 * bad credentials.
 */
EXPORT tag_typedef_t authtag_forbidden_ref;
tag_typedef_t authtag_forbidden;

/**@def AUTHTAG_ANONYMOUS()
 *
 * Allow anonymous access.
 *
 * When given a true argument, the tag AUTHTAG_ANONYMOUS() allows
 * authentication module to accept the account "anonymous" with an empty
 * password. The auth_status_t::as_anonymous flag is set in auth_status_t
 * structure after anonymous authentication.
 */
EXPORT tag_typedef_t authtag_anonymous_ref;
tag_typedef_t authtag_anonymous;

/**@def AUTHTAG_FAKE()
 *
 * Fake authentication process.
 *
 * When given a true argument, the tag AUTHTAG_FAKE() causes authentication
 * module to allow access with any password when the username is valid. The
 * auth_status_t::as_fake flag is set in auth_status_t structure after a
 * fake authentication.
 */
EXPORT tag_typedef_t authtag_fake_ref;
tag_typedef_t authtag_fake;

/**@def AUTHTAG_REMOTE()
 *
 * Remote authenticator URL.
 *
 * The tag AUTHTAG_REMOTE() is used to specify URL for remote authenticator.
 * The meaning of the URL is specific to the authentication module. The
 * authentication module is selected by AUTHTAG_METHOD().
 */
EXPORT tag_typedef_t authtag_remote_ref;
tag_typedef_t authtag_remote;

/**@def AUTHTAG_ALLOW()
 *
 * Comma-separated list of methods that are not challenged.
 *
 * The tag AUTHTAG_ALLOW() takes its argument a string containing a
 * comma-separated list of methods, for example,
 * @code
 * AUTHTAG_ALLOW("ACK, BYE, CANCEL").
 * @endcode
 *
 * The specified methods are not challenged by the authentication module.
 * For example, this may include SIP ACK method or SIP methods only used
 * within an already established dialog.
 */
EXPORT tag_typedef_t authtag_allow_ref;
tag_typedef_t authtag_allow;

/**@def AUTHTAG_MASTER_KEY()
 *
 * Private master key for the authentication module.
 *
 * The tag AUTHTAG_MASTER_KEY() specifies a private master key that can be
 * used by the authentication module for various purposes (for instance,
 * validating that nonces are really generated by it).
 */
EXPORT tag_typedef_t authtag_master_key_ref;
tag_typedef_t authtag_master_key;

/**@def AUTHTAG_CACHE_USERS()
 *
 * Time to cache user data.
 *
 * The tag AUTHTAG_CACHE_USERS() specifies how many seconds the user data is
 * cached locally. Default value is typically 30 minutes.
 */
EXPORT tag_typedef_t authtag_cache_users_ref;
tag_typedef_t authtag_cache_users;

/**@def AUTHTAG_CACHE_ERRORS()
 *
 * Time to cache errors.
 *
 * The tag AUTHTAG_CACHE_ERRORS() specifies the lifetime in seconds for
 * errors in the local authentication data cache. Note that the errors
 * generated locally (e.g., because of connectivity problem with
 * authentication server) have maximum lifetime of 2 minutes.
 */
EXPORT tag_typedef_t authtag_cache_errors_ref;
tag_typedef_t authtag_cache_errors;


#include <windows.h>

BOOL WINAPI DllMain(HINSTANCE hInst, DWORD fwdReason, LPVOID fImpLoad)
{
  tag_typedef_t _authtag_cache_users = UINTTAG_TYPEDEF(cache_users);
  tag_typedef_t _authtag_cache_users_ref =
    REFTAG_TYPEDEF(authtag_cache_users);
  tag_typedef_t _authtag_forbidden = BOOLTAG_TYPEDEF(forbidden);
  tag_typedef_t _authtag_forbidden_ref =
    REFTAG_TYPEDEF(authtag_forbidden);
  tag_typedef_t _authtag_blacklist = UINTTAG_TYPEDEF(blacklist);
  tag_typedef_t _authtag_blacklist_ref =
    REFTAG_TYPEDEF(authtag_blacklist);
  tag_typedef_t _authtag_opaque = STRTAG_TYPEDEF(opaque);
  tag_typedef_t _authtag_opaque_ref =
    REFTAG_TYPEDEF(authtag_opaque);
  tag_typedef_t _authtag_max_ncount = UINTTAG_TYPEDEF(max_ncount);
  tag_typedef_t _authtag_max_ncount_ref =
    REFTAG_TYPEDEF(authtag_max_ncount);
  tag_typedef_t _authtag_remote = URLTAG_TYPEDEF(remote);
  tag_typedef_t _authtag_remote_ref =
    REFTAG_TYPEDEF(authtag_remote);
  tag_typedef_t _authtag_anonymous = BOOLTAG_TYPEDEF(anonymous);
  tag_typedef_t _authtag_anonymous_ref =
    REFTAG_TYPEDEF(authtag_anonymous);
  tag_typedef_t _authtag_next_expires = UINTTAG_TYPEDEF(next_expires);
  tag_typedef_t _authtag_next_expires_ref =
    REFTAG_TYPEDEF(authtag_next_expires);
  tag_typedef_t _authtag_allow = STRTAG_TYPEDEF(allow);
  tag_typedef_t _authtag_allow_ref =
    REFTAG_TYPEDEF(authtag_allow);
  tag_typedef_t _authtag_expires = UINTTAG_TYPEDEF(expires);
  tag_typedef_t _authtag_expires_ref =
    REFTAG_TYPEDEF(authtag_expires);
  tag_typedef_t _authtag_algorithm = STRTAG_TYPEDEF(algorithm);
  tag_typedef_t _authtag_algorithm_ref =
    REFTAG_TYPEDEF(authtag_algorithm);
  tag_typedef_t _authtag_module = PTRTAG_TYPEDEF(module);
  tag_typedef_t _authtag_module_ref =
    REFTAG_TYPEDEF(authtag_module);
  tag_typedef_t _authtag_qop = STRTAG_TYPEDEF(qop);
  tag_typedef_t _authtag_qop_ref =
    REFTAG_TYPEDEF(authtag_qop);
  tag_typedef_t _authtag_cache_errors = UINTTAG_TYPEDEF(cache_errors);
  tag_typedef_t _authtag_cache_errors_ref =
    REFTAG_TYPEDEF(authtag_cache_errors);
  tag_typedef_t _authtag_method = STRTAG_TYPEDEF(method);
  tag_typedef_t _authtag_method_ref =
    REFTAG_TYPEDEF(authtag_method);
  tag_typedef_t _authtag_fake = BOOLTAG_TYPEDEF(fake);
  tag_typedef_t _authtag_fake_ref =
    REFTAG_TYPEDEF(authtag_fake);
  tag_typedef_t _authtag_any = NSTAG_TYPEDEF(*);
  tag_typedef_t _authtag_any_ref =
    REFTAG_TYPEDEF(authtag_any);
  tag_typedef_t _authtag_realm = STRTAG_TYPEDEF(realm);
  tag_typedef_t _authtag_realm_ref =
    REFTAG_TYPEDEF(authtag_realm);
  tag_typedef_t _authtag_master_key = STRTAG_TYPEDEF(master_key);
  tag_typedef_t _authtag_master_key_ref =
    REFTAG_TYPEDEF(authtag_master_key);
  tag_typedef_t _authtag_db = STRTAG_TYPEDEF(db);
  tag_typedef_t _authtag_db_ref =
    REFTAG_TYPEDEF(authtag_db);

  *(struct tag_type_s *)authtag_forbidden = *_authtag_forbidden;
  *(struct tag_type_s *)authtag_forbidden_ref = *_authtag_forbidden_ref;
  *(struct tag_type_s *)authtag_cache_users = *_authtag_cache_users;
  *(struct tag_type_s *)authtag_cache_users_ref = *_authtag_cache_users_ref;
  *(struct tag_type_s *)authtag_opaque = *_authtag_opaque;
  *(struct tag_type_s *)authtag_opaque_ref = *_authtag_opaque_ref;
  *(struct tag_type_s *)authtag_blacklist = *_authtag_blacklist;
  *(struct tag_type_s *)authtag_blacklist_ref = *_authtag_blacklist_ref;
  *(struct tag_type_s *)authtag_max_ncount = *_authtag_max_ncount;
  *(struct tag_type_s *)authtag_max_ncount_ref = *_authtag_max_ncount_ref;
  *(struct tag_type_s *)authtag_remote = *_authtag_remote;
  *(struct tag_type_s *)authtag_remote_ref = *_authtag_remote_ref;
  *(struct tag_type_s *)authtag_anonymous = *_authtag_anonymous;
  *(struct tag_type_s *)authtag_anonymous_ref = *_authtag_anonymous_ref;
  *(struct tag_type_s *)authtag_next_expires = *_authtag_next_expires;
  *(struct tag_type_s *)authtag_next_expires_ref = *_authtag_next_expires_ref;
  *(struct tag_type_s *)authtag_expires = *_authtag_expires;
  *(struct tag_type_s *)authtag_expires_ref = *_authtag_expires_ref;
  *(struct tag_type_s *)authtag_allow = *_authtag_allow;
  *(struct tag_type_s *)authtag_allow_ref = *_authtag_allow_ref;
  *(struct tag_type_s *)authtag_module = *_authtag_module;
  *(struct tag_type_s *)authtag_module_ref = *_authtag_module_ref;
  *(struct tag_type_s *)authtag_algorithm = *_authtag_algorithm;
  *(struct tag_type_s *)authtag_algorithm_ref = *_authtag_algorithm_ref;
  *(struct tag_type_s *)authtag_qop = *_authtag_qop;
  *(struct tag_type_s *)authtag_qop_ref = *_authtag_qop_ref;
  *(struct tag_type_s *)authtag_method = *_authtag_method;
  *(struct tag_type_s *)authtag_method_ref = *_authtag_method_ref;
  *(struct tag_type_s *)authtag_cache_errors = *_authtag_cache_errors;
  *(struct tag_type_s *)authtag_cache_errors_ref = *_authtag_cache_errors_ref;
  *(struct tag_type_s *)authtag_fake = *_authtag_fake;
  *(struct tag_type_s *)authtag_fake_ref = *_authtag_fake_ref;
  *(struct tag_type_s *)authtag_any = *_authtag_any;
  *(struct tag_type_s *)authtag_any_ref = *_authtag_any_ref;
  *(struct tag_type_s *)authtag_realm = *_authtag_realm;
  *(struct tag_type_s *)authtag_realm_ref = *_authtag_realm_ref;
  *(struct tag_type_s *)authtag_master_key = *_authtag_master_key;
  *(struct tag_type_s *)authtag_master_key_ref = *_authtag_master_key_ref;
  *(struct tag_type_s *)authtag_db = *_authtag_db;
  *(struct tag_type_s *)authtag_db_ref = *_authtag_db_ref;

  return TRUE;
}

#endif
